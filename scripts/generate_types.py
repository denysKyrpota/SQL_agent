#!/usr/bin/env python3
"""
Generate TypeScript type definitions from SQLite database schema.

This script reads the database schema and creates TypeScript interfaces
for all tables, providing type safety in the frontend.
"""

import sqlite3
import sys
from pathlib import Path
from typing import Dict, List, Tuple


# SQLite to TypeScript type mapping
TYPE_MAPPING = {
    'integer': 'number',
    'int': 'number',
    'real': 'number',
    'float': 'number',
    'double': 'number',
    'text': 'string',
    'varchar': 'string',
    'char': 'string',
    'blob': 'Uint8Array',
    'boolean': 'boolean',
    'date': 'string',  # ISO 8601 date strings
    'datetime': 'string',  # ISO 8601 datetime strings
    'timestamp': 'string',  # ISO 8601 timestamp strings
}


def get_sqlite_type(column_type: str) -> str:
    """Convert SQLite column type to TypeScript type."""
    # Remove size specifications and convert to lowercase
    base_type = column_type.split('(')[0].strip().lower()
    return TYPE_MAPPING.get(base_type, 'unknown')


def is_nullable(not_null: int, default_value: str) -> bool:
    """Determine if a column is nullable."""
    # not_null: 0 = nullable, 1 = not null
    # Even if NOT NULL, if there's a default value, treat as non-nullable
    return not_null == 0


def get_table_schema(cursor: sqlite3.Cursor, table_name: str) -> List[Tuple]:
    """Get schema information for a table."""
    cursor.execute(f"PRAGMA table_info({table_name})")
    return cursor.fetchall()


def generate_interface(table_name: str, columns: List[Tuple]) -> str:
    """Generate TypeScript interface for a table."""
    # Convert snake_case table name to PascalCase
    interface_name = ''.join(word.capitalize() for word in table_name.split('_'))
    
    lines = [f"export interface {interface_name} {{"]
    
    for column in columns:
        cid, name, col_type, not_null, default_value, pk = column
        
        ts_type = get_sqlite_type(col_type)
        nullable = is_nullable(not_null, default_value)
        
        # Add nullable marker if applicable
        optional_marker = '?' if nullable else ''
        null_type = ' | null' if nullable else ''
        
        # Add JSDoc comment for primary keys and special fields
        if pk:
            lines.append(f"  /** Primary key */")
        elif 'created_at' in name or 'updated_at' in name or name.endswith('_at'):
            lines.append(f"  /** ISO 8601 timestamp */")
        elif name.endswith('_id') and not pk:
            lines.append(f"  /** Foreign key reference */")
        
        lines.append(f"  {name}{optional_marker}: {ts_type}{null_type};")
    
    lines.append("}")
    return '\n'.join(lines)


def generate_type_guards(table_name: str) -> str:
    """Generate type guard function for runtime type checking."""
    interface_name = ''.join(word.capitalize() for word in table_name.split('_'))
    guard_name = f"is{interface_name}"
    
    return f"""export function {guard_name}(obj: any): obj is {interface_name} {{
  return typeof obj === 'object' && obj !== null;
}}"""


def main():
    """Main function to generate TypeScript types."""
    # Path configuration
    project_root = Path(__file__).parent.parent
    db_path = project_root / 'data' / 'app_data' / 'app.db'
    output_path = project_root / 'frontend' / 'src' / 'types' / 'database.types.ts'
    
    # Check if database exists
    if not db_path.exists():
        print(f"Error: Database not found at {db_path}")
        print("Please run 'make db-init' first to create the database.")
        sys.exit(1)
    
    # Connect to database
    conn = sqlite3.connect(str(db_path))
    cursor = conn.cursor()
    
    # Get all tables
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'")
    tables = [row[0] for row in cursor.fetchall()]
    
    if not tables:
        print("Warning: No tables found in database")
        sys.exit(1)
    
    # Generate TypeScript content
    content_lines = [
        "/**",
        " * Auto-generated TypeScript types from SQLite database schema",
        " * Generated by: scripts/generate_types.py",
        " * DO NOT EDIT THIS FILE MANUALLY",
        " *",
        " * To regenerate: make generate-types",
        " */",
        "",
    ]
    
    # Generate interfaces for each table
    for table_name in sorted(tables):
        columns = get_table_schema(cursor, table_name)
        
        content_lines.append(f"// Table: {table_name}")
        content_lines.append(generate_interface(table_name, columns))
        content_lines.append("")
    
    # Add utility types
    content_lines.extend([
        "// Utility Types",
        "",
        "/** ID type for all primary keys */",
        "export type ID = number;",
        "",
        "/** Timestamp string in ISO 8601 format */",
        "export type Timestamp = string;",
        "",
        "/** Role types for users */",
        "export type UserRole = 'admin' | 'user';",
        "",
        "/** Query attempt status types */",
        "export type QueryStatus = 'not_executed' | 'failed_generation' | 'failed_execution' | 'success' | 'timeout';",
        "",
    ])
    
    # Create output directory if it doesn't exist
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Write to file
    output_path.write_text('\n'.join(content_lines))
    
    # Close database connection
    conn.close()
    
    print(f"✓ Generated TypeScript types for {len(tables)} tables:")
    for table in tables:
        print(f"  - {table}")
    print(f"\n✓ Output written to: {output_path.relative_to(project_root)}")
    

if __name__ == '__main__':
    main()